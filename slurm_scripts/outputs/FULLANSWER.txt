SELECTED CONFIG FILES: gqa/general_config,config_codellama,gqa/save_codex,gqa/train
LOADING MODEL: DISABLED
INFO 03-09 11:43:15 __init__.py:183] Automatically detected platform cuda.
INFO 03-09 11:43:28 config.py:526] This model supports multiple tasks: {'generate', 'reward', 'classify', 'score', 'embed'}. Defaulting to 'generate'.
INFO 03-09 11:43:28 llm_engine.py:232] Initializing a V0 LLM engine (v0.7.1) with config: model='codellama/CodeLlama-7b-Instruct-hf', speculative_config=None, tokenizer='codellama/CodeLlama-7b-Instruct-hf', skip_tokenizer_init=False, tokenizer_mode=auto, revision=None, override_neuron_config=None, tokenizer_revision=None, trust_remote_code=False, dtype=torch.bfloat16, max_seq_len=16384, download_dir=None, load_format=LoadFormat.AUTO, tensor_parallel_size=1, pipeline_parallel_size=1, disable_custom_all_reduce=False, quantization=None, enforce_eager=False, kv_cache_dtype=auto,  device_config=cuda, decoding_config=DecodingConfig(guided_decoding_backend='xgrammar'), observability_config=ObservabilityConfig(otlp_traces_endpoint=None, collect_model_forward_time=False, collect_model_execute_time=False), seed=0, served_model_name=codellama/CodeLlama-7b-Instruct-hf, num_scheduler_steps=1, multi_step_stream_outputs=True, enable_prefix_caching=False, chunked_prefill_enabled=False, use_async_output_proc=True, disable_mm_preprocessor_cache=False, mm_processor_kwargs=None, pooler_config=None, compilation_config={"splitting_ops":[],"compile_sizes":[],"cudagraph_capture_sizes":[256,248,240,232,224,216,208,200,192,184,176,168,160,152,144,136,128,120,112,104,96,88,80,72,64,56,48,40,32,24,16,8,4,2,1],"max_capture_size":256}, use_cached_outputs=False, 
INFO 03-09 11:43:29 cuda.py:235] Using Flash Attention backend.
INFO 03-09 11:43:30 model_runner.py:1111] Starting to load model codellama/CodeLlama-7b-Instruct-hf...
INFO 03-09 11:43:30 weight_utils.py:251] Using model weights format ['*.safetensors']
INFO 03-09 11:45:39 model_runner.py:1116] Loading model weights took 12.5562 GB
INFO 03-09 11:45:41 worker.py:266] Memory profiling takes 1.48 seconds
INFO 03-09 11:45:41 worker.py:266] the current vLLM instance can use total_gpu_memory (79.15GiB) x gpu_memory_utilization (0.90) = 71.24GiB
INFO 03-09 11:45:41 worker.py:266] model weights take 12.56GiB; non_torch_memory takes 0.09GiB; PyTorch activation peak memory takes 1.39GiB; the rest of the memory reserved for KV Cache is 57.20GiB.
INFO 03-09 11:45:41 executor_base.py:108] # CUDA blocks: 7321, # CPU blocks: 512
INFO 03-09 11:45:41 executor_base.py:113] Maximum concurrency for 16384 tokens per request: 7.15x
INFO 03-09 11:45:42 model_runner.py:1435] Capturing cudagraphs for decoding. This may lead to unexpected consequences if the model is not static. To run the model in eager mode, set 'enforce_eager=True' or use '--enforce-eager' in the CLI. If out-of-memory error occurs during cudagraph capture, consider decreasing `gpu_memory_utilization` or switching to eager mode. You can also reduce the `max_num_seqs` as needed to decrease memory usage.
INFO 03-09 11:46:01 model_runner.py:1563] Graph capturing finished in 19 secs, took 0.85 GiB
INFO 03-09 11:46:01 llm_engine.py:429] init engine (profile, create kv cache, warmup model) took 22.33 seconds
modelo: <class 'vision_models.codellama'> , proceso:  codellama
{'codellama': <function make_fn.<locals>._function at 0x7fea3a1ef060>}
['from PIL import Image\nfrom vision_functions import find_in_image, simple_qa, verify_property, best_text_match\n\ndef bool_to_yesno(bool_answer: bool)->str:\n    return "yes" if bool_answer else "no"\n\nclass ImagePatch:\n    """A Python class containing a crop of an image centered around a particular object, as well as relevant information.\n    Attributes\n    ----------\n    cropped_image : array_like\n        An array-like of the cropped image taken from the original image.\n    left : int\n        An int describing the position of the left border of the crop\'s bounding box in the original image.\n    lower : int\n        An int describing the position of the bottom border of the crop\'s bounding box in the original image.\n    right : int\n        An int describing the position of the right border of the crop\'s bounding box in the original image.\n    upper : int\n        An int describing the position of the top border of the crop\'s bounding box in the original image.\n\n    Methods\n    -------\n    find(object_name: str)->List[ImagePatch]\n        Returns a list of new ImagePatch objects containing crops of the image centered around any objects found in the image matching the object_name.\n    simple_query(question: str=None)->str\n        Returns the answer to a basic question asked about the image. If no question is provided, returns the answer to "What is this?".\n    exists(object_name: str)->bool\n        Returns True if the object specified by object_name is found in the image, and False otherwise.\n    verify_property(property: str)->bool\n        Returns True if the property is met, and False otherwise.\n    best_text_match(string1: str, string2: str)->str\n        Returns the string that best matches the image.\n    crop(left: int, lower: int, right: int, upper: int)->ImagePatch\n        Returns a new ImagePatch object containing a crop of the image at the given coordinates.\n        """\n\n    def __init__(self, image, left: int=None, lower: int=None, right: int=None, upper: int=None):\n        """Initializes an ImagePatch object by cropping the image at the given coordinates and stores the coordinates as attributes.\n        If no coordinates are provided, the image is left unmodified, and the coordinates are set to the dimensions of the image.\n        Parameters\n        -------\n        image : array_like\n            An array-like of the original image.\n        left : int\n            An int describing the position of the left border of the crop\'s bounding box in the original image.\n        lower : int\n            An int describing the position of the bottom border of the crop\'s bounding box in the original image.\n        right : int\n            An int describing the position of the right border of the crop\'s bounding box in the original image.\n        upper : int\n            An int describing the position of the top border of the crop\'s bounding box in the original image.\n\n        """\n        if left is None and right is None and upper is None and lower is None:\n            self.cropped_image = image\n            self.left = 0\n            self.lower = 0\n            self.right = image.shape[2]  # width\n            self.upper = image.shape[1]  # height\n        else:\n            self.cropped_image = image[:, lower:upper, left:right]\n            self.left = left\n            self.upper = upper\n            self.right = right\n            self.lower = lower\n\n        self.width = self.cropped_image.shape[2]\n        self.height = self.cropped_image.shape[1]\n\n        self.horizontal_center = (self.left + self.right) / 2\n        self.vertical_center = (self.lower + self.upper) / 2\n\n    def find(self, object_name: str)->List["ImagePatch"]:\n        """Returns a new ImagePatch object containing the crop of the image centered around the object specified by object_name.\n        Parameters\n        -------\n        object_name : str\n            A string describing the name of the object to be found in the image.\n        """\n        return find_in_image(self.cropped_image, object_name)\n\n    def simple_query(self, question: str=None)->str:\n        """Returns the answer to a basic question asked about the image. If no question is provided, returns the answer to "What is this?".\n        Parameters\n        -------\n        question : str\n            A string describing the question to be asked.\n\n        Examples\n        -------\n\n        >>> # Which kind of animal is not eating?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     animal_patches = image_patch.find("animal")\n        >>>     for animal_patch in animal_patches:\n        >>>         if not animal_patch.verify_property("animal", "eating"):\n        >>>             return animal_patch.simple_query("What kind of animal is eating?") # crop would include eating so keep it in the query\n        >>>     # If no animal is not eating, query the image directly\n        >>>     return image_patch.simple_query("Which kind of animal is not eating?")\n\n        >>> # What is in front of the horse?\n        >>> # contains a relation (around, next to, on, near, on top of, in front of, behind, etc), so ask directly\n        >>> return image_patch.simple_query("What is in front of the horse?")\n        >>>\n        """\n        return simple_qa(self.cropped_image, question)\n\n    def exists(self, object_name: str)->bool:\n        """Returns True if the object specified by object_name is found in the image, and False otherwise.\n        Parameters\n        -------\n        object_name : str\n            A string describing the name of the object to be found in the image.\n\n        Examples\n        -------\n        >>> # Are there both cakes and gummy bears in the photo?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     is_cake = image_patch.exists("cake")\n        >>>     is_gummy_bear = image_patch.exists("gummy bear")\n        >>>     return bool_to_yesno(is_cake and is_gummy_bear)\n        """\n        return len(self.find(object_name)) > 0\n\n    def verify_property(self, object_name: str, property: str)->bool:\n        """Returns True if the object possesses the property, and False otherwise.\n        Differs from \'exists\' in that it presupposes the existence of the object specified by object_name, instead checking whether the object possesses the property.\n        Parameters\n        -------\n        object_name : str\n            A string describing the name of the object to be found in the image.\n        property : str\n            A string describing the property to be checked.\n\n        Examples\n        -------\n        >>> # Do the letters have blue color?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     letters_patches = image_patch.find("letters")\n        >>>     # Question assumes only one letter patch\n        >>>     if len(letters_patches) == 0:\n        >>>         # If no letters are found, query the image directly\n        >>>         return image_patch.simple_query("Do the letters have blue color?")\n        >>>     return bool_to_yesno(letters_patches[0].verify_property("letters", "blue"))\n        """\n        return verify_property(self.cropped_image, object_name, property)\n\n    def best_text_match(self, option_list: List[str]) -> str:\n        """Returns the string that best matches the image.\n        Parameters\n        -------\n        option_list : str\n            A list with the names of the different options\n        prefix : str\n            A string with the prefixes to append to the options\n\n        Examples\n        -------\n        >>> # Is the cap gold or white?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     cap_patches = image_patch.find("cap")\n        >>>     # Question assumes one cap patch\n        >>>     if len(cap_patches) == 0:\n        >>>         # If no cap is found, query the image directly\n        >>>         return image_patch.simple_query("Is the cap gold or white?")\n        >>>     return cap_patches[0].best_text_match(["gold", "white"])\n        """\n        return best_text_match(self.cropped_image, option_list)\n\n    def crop(self, left: int, lower: int, right: int, upper: int)->"ImagePatch":\n        """Returns a new ImagePatch cropped from the current ImagePatch.\n        Parameters\n        -------\n        left : int\n            The leftmost pixel of the cropped image.\n        lower : int\n            The lowest pixel of the cropped image.\n        right : int\n            The rightmost pixel of the cropped image.\n        upper : int\n            The uppermost pixel of the cropped image.\n        -------\n        """\n        return ImagePatch(self.cropped_image, left, lower, right, upper)\n\n# Examples of using ImagePatch\n# Is there a backpack to the right of the man?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    man_patches = image_patch.find("man")\n    # Question assumes one man patch\n    if len(man_patches) == 0:\n        # If no man is found, query the image directly\n        return image_patch.simple_query("Is there a backpack to the right of the man?")\n    man_patch = man_patches[0]\n    backpack_patches = image_patch.find("backpack")\n    # Question assumes one backpack patch\n    if len(backpack_patches) == 0:\n        return "no"\n    for backpack_patch in backpack_patches:\n        if backpack_patch.horizontal_center > man_patch.horizontal_center:\n            return "yes"\n    return "no"\n\n# In which part is the bread, the bottom or the top?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    bread_patches = image_patch.find("bread")\n    # Question assumes only one bread patch\n    if len(bread_patches) == 0:\n        # If no bread is found, query the image directly\n        return image_patch.simple_query("In which part is the bread, the bottom or the top?")\n    if bread_patches[0].vertical_center < image_patch.vertical_center:\n        return "bottom"\n    else:\n        return "top"\n\n# What type of weather do you see in the photograph?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    return image_patch.simple_query("What type of weather do you see in the photograph?")\n\n# Who is the man staring at?\ndef execute_command(image)->str:\n    # asks for the predicate of a relational verb (staring at), so ask directly\n    image_patch = ImagePatch(image)\n    return image_patch.simple_query("Who is the man staring at?")\n\n# What toy is wearing a shirt?\ndef execute_command(image)->str:\n    # not a relational verb so go step by step\n    image_patch = ImagePatch(image)\n    toy_patches = image_patch.find("toy")\n    # Question assumes only one toy patch\n    if len(toy_patches) == 0:\n        # If no toy is found, query the image directly\n        return image_patch.simple_query("What toy is wearing a shirt?")\n    for toy_patch in toy_patches:\n        is_wearing_shirt = (toy_patch.simple_query("Is the toy wearing a shirt?") == "yes")\n        if is_wearing_shirt:\n            return toy_patch.simple_query("What toy is wearing a shirt?") # crop would include the shirt so keep it in the query\n    # If no toy is wearing a shirt, pick the first toy\n    return toy_patches[0].simple_query("What toy is wearing a shirt?")\n\n# What is behind the pole?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    # contains a relation (around, next to, on, near, on top of, in front of, behind, etc), so ask directly\n    return image_patch.simple_query("What is behind the pole?")\n\n# Are there bagels or lemons?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    is_bagel = image_patch.exists("bagel")\n    is_lemon = image_patch.exists("lemon")\n    return bool_to_yesno(is_bagel or is_lemon)\n\n# Is that blanket to the right of a pillow?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    blanket_patches = image_patch.find("blanket")\n    # Question assumes only one blanket patch\n    if len(blanket_patches) == 0:\n        # If no blanket is found, query the image directly\n        return image_patch.simple_query("Is that blanket to the right of a pillow?")\n    for blanket_patch in blanket_patches:\n        pillow_patches = image_patch.find("pillow")\n        for pillow_patch in pillow_patches:\n            if pillow_patch.horizontal_center > blanket_patch.horizontal_center:\n                return "yes"\n    return "no"\n\n# Are the white blinds to the right of a clock?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    white_blinds_patches = image_patch.find("white blinds")\n    # Question assumes only one white blinds patch\n    if len(white_blinds_patches) == 0:\n        # If no white blinds are found, query the image directly\n        return image_patch.simple_query("Are the white blinds to the right of a clock?")\n    for white_blinds_patch in white_blinds_patches:\n        clock_patches = image_patch.find("clock")\n        for clock_patch in clock_patches:\n            if clock_patch.horizontal_center > white_blinds_patch.horizontal_center:\n                return "yes"\n    return "no"\n\ntest_images = ["google_doc_blank.png", "ZQ3a8hiBXHY.png"]\n\nfor fname in test_images:\n    image = Image.open(fname)\n    image_patch = ImagePatch(image)\n    print(fname, "check yes no:", image_patch.simple_query("there a blanket in this image?"))\n    print(fname, "check yes no question:", image_patch.simple_query("is there a shirt in the right part of the image?"))\n    print(fname, "check exists:", image_patch.exists("clock"))\n    print(fname, "check verify color:", image_patch.verify_property("table", "white"))\n    print(fname, "check best text match:", image_patch.best_text_match(["spread", "blotter", "background"]))\n    print(fname, "check crop of the secret agent of \'*\'", image_patch.crop(4, 85, 381, 96).simple_query("what is the secret agent of \'*\'"))\n    print(fname, "\\n")\n\ntest_questions = ["are there bagels/lemons?", "Is that blanket to the right of a pillow?", "are the white blinds to the right of a clock?", \\\n"are tall/short of the picture?"]\n', 'from PIL import Image\nfrom vision_functions import find_in_image, simple_qa, verify_property, best_text_match\n\ndef bool_to_yesno(bool_answer: bool)->str:\n    return "yes" if bool_answer else "no"\n\nclass ImagePatch:\n    """A Python class containing a crop of an image centered around a particular object, as well as relevant information.\n    Attributes\n    ----------\n    cropped_image : array_like\n        An array-like of the cropped image taken from the original image.\n    left : int\n        An int describing the position of the left border of the crop\'s bounding box in the original image.\n    lower : int\n        An int describing the position of the bottom border of the crop\'s bounding box in the original image.\n    right : int\n        An int describing the position of the right border of the crop\'s bounding box in the original image.\n    upper : int\n        An int describing the position of the top border of the crop\'s bounding box in the original image.\n\n    Methods\n    -------\n    find(object_name: str)->List[ImagePatch]\n        Returns a list of new ImagePatch objects containing crops of the image centered around any objects found in the image matching the object_name.\n    simple_query(question: str=None)->str\n        Returns the answer to a basic question asked about the image. If no question is provided, returns the answer to "What is this?".\n    exists(object_name: str)->bool\n        Returns True if the object specified by object_name is found in the image, and False otherwise.\n    verify_property(property: str)->bool\n        Returns True if the property is met, and False otherwise.\n    best_text_match(string1: str, string2: str)->str\n        Returns the string that best matches the image.\n    crop(left: int, lower: int, right: int, upper: int)->ImagePatch\n        Returns a new ImagePatch object containing a crop of the image at the given coordinates.\n        """\n\n    def __init__(self, image, left: int=None, lower: int=None, right: int=None, upper: int=None):\n        """Initializes an ImagePatch object by cropping the image at the given coordinates and stores the coordinates as attributes.\n        If no coordinates are provided, the image is left unmodified, and the coordinates are set to the dimensions of the image.\n        Parameters\n        -------\n        image : array_like\n            An array-like of the original image.\n        left : int\n            An int describing the position of the left border of the crop\'s bounding box in the original image.\n        lower : int\n            An int describing the position of the bottom border of the crop\'s bounding box in the original image.\n        right : int\n            An int describing the position of the right border of the crop\'s bounding box in the original image.\n        upper : int\n            An int describing the position of the top border of the crop\'s bounding box in the original image.\n\n        """\n        if left is None and right is None and upper is None and lower is None:\n            self.cropped_image = image\n            self.left = 0\n            self.lower = 0\n            self.right = image.shape[2]  # width\n            self.upper = image.shape[1]  # height\n        else:\n            self.cropped_image = image[:, lower:upper, left:right]\n            self.left = left\n            self.upper = upper\n            self.right = right\n            self.lower = lower\n\n        self.width = self.cropped_image.shape[2]\n        self.height = self.cropped_image.shape[1]\n\n        self.horizontal_center = (self.left + self.right) / 2\n        self.vertical_center = (self.lower + self.upper) / 2\n\n    def find(self, object_name: str)->List["ImagePatch"]:\n        """Returns a new ImagePatch object containing the crop of the image centered around the object specified by object_name.\n        Parameters\n        -------\n        object_name : str\n            A string describing the name of the object to be found in the image.\n        """\n        return find_in_image(self.cropped_image, object_name)\n\n    def simple_query(self, question: str=None)->str:\n        """Returns the answer to a basic question asked about the image. If no question is provided, returns the answer to "What is this?".\n        Parameters\n        -------\n        question : str\n            A string describing the question to be asked.\n\n        Examples\n        -------\n\n        >>> # Which kind of animal is not eating?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     animal_patches = image_patch.find("animal")\n        >>>     for animal_patch in animal_patches:\n        >>>         if not animal_patch.verify_property("animal", "eating"):\n        >>>             return animal_patch.simple_query("What kind of animal is eating?") # crop would include eating so keep it in the query\n        >>>     # If no animal is not eating, query the image directly\n        >>>     return image_patch.simple_query("Which kind of animal is not eating?")\n\n        >>> # What is in front of the horse?\n        >>> # contains a relation (around, next to, on, near, on top of, in front of, behind, etc), so ask directly\n        >>> return image_patch.simple_query("What is in front of the horse?")\n        >>>\n        """\n        return simple_qa(self.cropped_image, question)\n\n    def exists(self, object_name: str)->bool:\n        """Returns True if the object specified by object_name is found in the image, and False otherwise.\n        Parameters\n        -------\n        object_name : str\n            A string describing the name of the object to be found in the image.\n\n        Examples\n        -------\n        >>> # Are there both cakes and gummy bears in the photo?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     is_cake = image_patch.exists("cake")\n        >>>     is_gummy_bear = image_patch.exists("gummy bear")\n        >>>     return bool_to_yesno(is_cake and is_gummy_bear)\n        """\n        return len(self.find(object_name)) > 0\n\n    def verify_property(self, object_name: str, property: str)->bool:\n        """Returns True if the object possesses the property, and False otherwise.\n        Differs from \'exists\' in that it presupposes the existence of the object specified by object_name, instead checking whether the object possesses the property.\n        Parameters\n        -------\n        object_name : str\n            A string describing the name of the object to be found in the image.\n        property : str\n            A string describing the property to be checked.\n\n        Examples\n        -------\n        >>> # Do the letters have blue color?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     letters_patches = image_patch.find("letters")\n        >>>     # Question assumes only one letter patch\n        >>>     if len(letters_patches) == 0:\n        >>>         # If no letters are found, query the image directly\n        >>>         return image_patch.simple_query("Do the letters have blue color?")\n        >>>     return bool_to_yesno(letters_patches[0].verify_property("letters", "blue"))\n        """\n        return verify_property(self.cropped_image, object_name, property)\n\n    def best_text_match(self, option_list: List[str]) -> str:\n        """Returns the string that best matches the image.\n        Parameters\n        -------\n        option_list : str\n            A list with the names of the different options\n        prefix : str\n            A string with the prefixes to append to the options\n\n        Examples\n        -------\n        >>> # Is the cap gold or white?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     cap_patches = image_patch.find("cap")\n        >>>     # Question assumes one cap patch\n        >>>     if len(cap_patches) == 0:\n        >>>         # If no cap is found, query the image directly\n        >>>         return image_patch.simple_query("Is the cap gold or white?")\n        >>>     return cap_patches[0].best_text_match(["gold", "white"])\n        """\n        return best_text_match(self.cropped_image, option_list)\n\n    def crop(self, left: int, lower: int, right: int, upper: int)->"ImagePatch":\n        """Returns a new ImagePatch cropped from the current ImagePatch.\n        Parameters\n        -------\n        left : int\n            The leftmost pixel of the cropped image.\n        lower : int\n            The lowest pixel of the cropped image.\n        right : int\n            The rightmost pixel of the cropped image.\n        upper : int\n            The uppermost pixel of the cropped image.\n        -------\n        """\n        return ImagePatch(self.cropped_image, left, lower, right, upper)\n\n# Examples of using ImagePatch\n# Is there a backpack to the right of the man?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    man_patches = image_patch.find("man")\n    # Question assumes one man patch\n    if len(man_patches) == 0:\n        # If no man is found, query the image directly\n        return image_patch.simple_query("Is there a backpack to the right of the man?")\n    man_patch = man_patches[0]\n    backpack_patches = image_patch.find("backpack")\n    # Question assumes one backpack patch\n    if len(backpack_patches) == 0:\n        return "no"\n    for backpack_patch in backpack_patches:\n        if backpack_patch.horizontal_center > man_patch.horizontal_center:\n            return "yes"\n    return "no"\n\n# In which part is the bread, the bottom or the top?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    bread_patches = image_patch.find("bread")\n    # Question assumes only one bread patch\n    if len(bread_patches) == 0:\n        # If no bread is found, query the image directly\n        return image_patch.simple_query("In which part is the bread, the bottom or the top?")\n    if bread_patches[0].vertical_center < image_patch.vertical_center:\n        return "bottom"\n    else:\n        return "top"\n\n# What type of weather do you see in the photograph?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    return image_patch.simple_query("What type of weather do you see in the photograph?")\n\n# Who is the man staring at?\ndef execute_command(image)->str:\n    # asks for the predicate of a relational verb (staring at), so ask directly\n    image_patch = ImagePatch(image)\n    return image_patch.simple_query("Who is the man staring at?")\n\n# What toy is wearing a shirt?\ndef execute_command(image)->str:\n    # not a relational verb so go step by step\n    image_patch = ImagePatch(image)\n    toy_patches = image_patch.find("toy")\n    # Question assumes only one toy patch\n    if len(toy_patches) == 0:\n        # If no toy is found, query the image directly\n        return image_patch.simple_query("What toy is wearing a shirt?")\n    for toy_patch in toy_patches:\n        is_wearing_shirt = (toy_patch.simple_query("Is the toy wearing a shirt?") == "yes")\n        if is_wearing_shirt:\n            return toy_patch.simple_query("What toy is wearing a shirt?") # crop would include the shirt so keep it in the query\n    # If no toy is wearing a shirt, pick the first toy\n    return toy_patches[0].simple_query("What toy is wearing a shirt?")\n\n# What is behind the pole?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    # contains a relation (around, next to, on, near, on top of, in front of, behind, etc), so ask directly\n    return image_patch.simple_query("What is behind the pole?")\n\n# Are there bagels or lemons?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    is_bagel = image_patch.exists("bagel")\n    is_lemon = image_patch.exists("lemon")\n    return bool_to_yesno(is_bagel or is_lemon)\n\n# Is that blanket to the right of a pillow?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    blanket_patches = image_patch.find("blanket")\n    # Question assumes only one blanket patch\n    if len(blanket_patches) == 0:\n        # If no blanket is found, query the image directly\n        return image_patch.simple_query("Is that blanket to the right of a pillow?")\n    for blanket_patch in blanket_patches:\n        pillow_patches = image_patch.find("pillow")\n        for pillow_patch in pillow_patches:\n            if pillow_patch.horizontal_center > blanket_patch.horizontal_center:\n                return "yes"\n    return "no"\n\n# Which kind of furniture is to the left of the bed?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    bed_patches = image_patch.find("bed")\n    # Question assumes only one bed patch\n    if len(bed_patches) == 0:\n        # If no bed is found, query the image directly\n        return image_patch.simple_query("Which kind of furniture is to the left of the bed?")\n    bed_patch = bed_patches[0]\n    for i, object_name in enumerate([\n            "chair", "sofa", "dresser", "table", "nightstand", "bookshelf", "friend"]):\n        patches = image_patch.find(object_name)\n        for patch in patches:\n            if patch.horizontal_center < bed_patch.horizontal_center:\n                return str(i)\n    return "none"\n\n# How many girls are sleeping on the bed?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    sleeping_girl_patches = image_patch.find("sleeping girl")\n    return str(len(sleeping_girl_patches))\n\n# Is there a toy\ndef execute_command(image)->str:\n    # questions asks for a property of an object (sleeping), so ask directly\n    image_patch = ImagePatch(image)\n    return image_patch.simple_query("Is there a toy box?")\n\n# Are there gloves?\ndef execute_command(image)->str:\n    # questions asks for a property of an entity (are side), so ask directly\n    image_patch = ImagePatch(image)\n    glove_patches = image_patch.find("glove")\n    return str(len(glove_patches))\n\n# Is that toy inside or outside?\ndef execute_command(image)->str:\n    # questions asks for the location of the toy box (at the location of the man), so ask directly\n    image_patch = ImagePatch(image)\n    return image_patch.simple_query("Is that toy inside or outside?")\n\n', 'from PIL import Image\nfrom vision_functions import find_in_image, simple_qa, verify_property, best_text_match\n\ndef bool_to_yesno(bool_answer: bool)->str:\n    return "yes" if bool_answer else "no"\n\nclass ImagePatch:\n    """A Python class containing a crop of an image centered around a particular object, as well as relevant information.\n    Attributes\n    ----------\n    cropped_image : array_like\n        An array-like of the cropped image taken from the original image.\n    left : int\n        An int describing the position of the left border of the crop\'s bounding box in the original image.\n    lower : int\n        An int describing the position of the bottom border of the crop\'s bounding box in the original image.\n    right : int\n        An int describing the position of the right border of the crop\'s bounding box in the original image.\n    upper : int\n        An int describing the position of the top border of the crop\'s bounding box in the original image.\n\n    Methods\n    -------\n    find(object_name: str)->List[ImagePatch]\n        Returns a list of new ImagePatch objects containing crops of the image centered around any objects found in the image matching the object_name.\n    simple_query(question: str=None)->str\n        Returns the answer to a basic question asked about the image. If no question is provided, returns the answer to "What is this?".\n    exists(object_name: str)->bool\n        Returns True if the object specified by object_name is found in the image, and False otherwise.\n    verify_property(property: str)->bool\n        Returns True if the property is met, and False otherwise.\n    best_text_match(string1: str, string2: str)->str\n        Returns the string that best matches the image.\n    crop(left: int, lower: int, right: int, upper: int)->ImagePatch\n        Returns a new ImagePatch object containing a crop of the image at the given coordinates.\n        """\n\n    def __init__(self, image, left: int=None, lower: int=None, right: int=None, upper: int=None):\n        """Initializes an ImagePatch object by cropping the image at the given coordinates and stores the coordinates as attributes.\n        If no coordinates are provided, the image is left unmodified, and the coordinates are set to the dimensions of the image.\n        Parameters\n        -------\n        image : array_like\n            An array-like of the original image.\n        left : int\n            An int describing the position of the left border of the crop\'s bounding box in the original image.\n        lower : int\n            An int describing the position of the bottom border of the crop\'s bounding box in the original image.\n        right : int\n            An int describing the position of the right border of the crop\'s bounding box in the original image.\n        upper : int\n            An int describing the position of the top border of the crop\'s bounding box in the original image.\n\n        """\n        if left is None and right is None and upper is None and lower is None:\n            self.cropped_image = image\n            self.left = 0\n            self.lower = 0\n            self.right = image.shape[2]  # width\n            self.upper = image.shape[1]  # height\n        else:\n            self.cropped_image = image[:, lower:upper, left:right]\n            self.left = left\n            self.upper = upper\n            self.right = right\n            self.lower = lower\n\n        self.width = self.cropped_image.shape[2]\n        self.height = self.cropped_image.shape[1]\n\n        self.horizontal_center = (self.left + self.right) / 2\n        self.vertical_center = (self.lower + self.upper) / 2\n\n    def find(self, object_name: str)->List["ImagePatch"]:\n        """Returns a new ImagePatch object containing the crop of the image centered around the object specified by object_name.\n        Parameters\n        -------\n        object_name : str\n            A string describing the name of the object to be found in the image.\n        """\n        return find_in_image(self.cropped_image, object_name)\n\n    def simple_query(self, question: str=None)->str:\n        """Returns the answer to a basic question asked about the image. If no question is provided, returns the answer to "What is this?".\n        Parameters\n        -------\n        question : str\n            A string describing the question to be asked.\n\n        Examples\n        -------\n\n        >>> # Which kind of animal is not eating?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     animal_patches = image_patch.find("animal")\n        >>>     for animal_patch in animal_patches:\n        >>>         if not animal_patch.verify_property("animal", "eating"):\n        >>>             return animal_patch.simple_query("What kind of animal is eating?") # crop would include eating so keep it in the query\n        >>>     # If no animal is not eating, query the image directly\n        >>>     return image_patch.simple_query("Which kind of animal is not eating?")\n\n        >>> # What is in front of the horse?\n        >>> # contains a relation (around, next to, on, near, on top of, in front of, behind, etc), so ask directly\n        >>> return image_patch.simple_query("What is in front of the horse?")\n        >>>\n        """\n        return simple_qa(self.cropped_image, question)\n\n    def exists(self, object_name: str)->bool:\n        """Returns True if the object specified by object_name is found in the image, and False otherwise.\n        Parameters\n        -------\n        object_name : str\n            A string describing the name of the object to be found in the image.\n\n        Examples\n        -------\n        >>> # Are there both cakes and gummy bears in the photo?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     is_cake = image_patch.exists("cake")\n        >>>     is_gummy_bear = image_patch.exists("gummy bear")\n        >>>     return bool_to_yesno(is_cake and is_gummy_bear)\n        """\n        return len(self.find(object_name)) > 0\n\n    def verify_property(self, object_name: str, property: str)->bool:\n        """Returns True if the object possesses the property, and False otherwise.\n        Differs from \'exists\' in that it presupposes the existence of the object specified by object_name, instead checking whether the object possesses the property.\n        Parameters\n        -------\n        object_name : str\n            A string describing the name of the object to be found in the image.\n        property : str\n            A string describing the property to be checked.\n\n        Examples\n        -------\n        >>> # Do the letters have blue color?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     letters_patches = image_patch.find("letters")\n        >>>     # Question assumes only one letter patch\n        >>>     if len(letters_patches) == 0:\n        >>>         # If no letters are found, query the image directly\n        >>>         return image_patch.simple_query("Do the letters have blue color?")\n        >>>     return bool_to_yesno(letters_patches[0].verify_property("letters", "blue"))\n        """\n        return verify_property(self.cropped_image, object_name, property)\n\n    def best_text_match(self, option_list: List[str]) -> str:\n        """Returns the string that best matches the image.\n        Parameters\n        -------\n        option_list : str\n            A list with the names of the different options\n        prefix : str\n            A string with the prefixes to append to the options\n\n        Examples\n        -------\n        >>> # Is the cap gold or white?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     cap_patches = image_patch.find("cap")\n        >>>     # Question assumes one cap patch\n        >>>     if len(cap_patches) == 0:\n        >>>         # If no cap is found, query the image directly\n        >>>         return image_patch.simple_query("Is the cap gold or white?")\n        >>>     return cap_patches[0].best_text_match(["gold", "white"])\n        """\n        return best_text_match(self.cropped_image, option_list)\n\n    def crop(self, left: int, lower: int, right: int, upper: int)->"ImagePatch":\n        """Returns a new ImagePatch cropped from the current ImagePatch.\n        Parameters\n        -------\n        left : int\n            The leftmost pixel of the cropped image.\n        lower : int\n            The lowest pixel of the cropped image.\n        right : int\n            The rightmost pixel of the cropped image.\n        upper : int\n            The uppermost pixel of the cropped image.\n        -------\n        """\n        return ImagePatch(self.cropped_image, left, lower, right, upper)\n\n# Examples of using ImagePatch\n# Is there a backpack to the right of the man?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    man_patches = image_patch.find("man")\n    # Question assumes one man patch\n    if len(man_patches) == 0:\n        # If no man is found, query the image directly\n        return image_patch.simple_query("Is there a backpack to the right of the man?")\n    man_patch = man_patches[0]\n    backpack_patches = image_patch.find("backpack")\n    # Question assumes one backpack patch\n    if len(backpack_patches) == 0:\n        return "no"\n    for backpack_patch in backpack_patches:\n        if backpack_patch.horizontal_center > man_patch.horizontal_center:\n            return "yes"\n    return "no"\n\n# In which part is the bread, the bottom or the top?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    bread_patches = image_patch.find("bread")\n    # Question assumes only one bread patch\n    if len(bread_patches) == 0:\n        # If no bread is found, query the image directly\n        return image_patch.simple_query("In which part is the bread, the bottom or the top?")\n    if bread_patches[0].vertical_center < image_patch.vertical_center:\n        return "bottom"\n    else:\n        return "top"\n\n# What type of weather do you see in the photograph?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    return image_patch.simple_query("What type of weather do you see in the photograph?")\n\n# Who is the man staring at?\ndef execute_command(image)->str:\n    # asks for the predicate of a relational verb (staring at), so ask directly\n    image_patch = ImagePatch(image)\n    return image_patch.simple_query("Who is the man staring at?")\n\n# What toy is wearing a shirt?\ndef execute_command(image)->str:\n    # not a relational verb so go step by step\n    image_patch = ImagePatch(image)\n    toy_patches = image_patch.find("toy")\n    # Question assumes only one toy patch\n    if len(toy_patches) == 0:\n        # If no toy is found, query the image directly\n        return image_patch.simple_query("What toy is wearing a shirt?")\n    for toy_patch in toy_patches:\n        is_wearing_shirt = (toy_patch.simple_query("Is the toy wearing a shirt?") == "yes")\n        if is_wearing_shirt:\n            return toy_patch.simple_query("What toy is wearing a shirt?") # crop would include the shirt so keep it in the query\n    # If no toy is wearing a shirt, pick the first toy\n    return toy_patches[0].simple_query("What toy is wearing a shirt?")\n\n# What is behind the pole?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    # contains a relation (around, next to, on, near, on top of, in front of, behind, etc), so ask directly\n    return image_patch.simple_query("What is behind the pole?")\n\n# Are there bagels or lemons?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    is_bagel = image_patch.exists("bagel")\n    is_lemon = image_patch.exists("lemon")\n    return bool_to_yesno(is_bagel or is_lemon)\n\n# Is that blanket to the right of a pillow?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    blanket_patches = image_patch.find("blanket")\n    # Question assumes only one blanket patch\n    if len(blanket_patches) == 0:\n        # If no blanket is found, query the image directly\n        return image_patch.simple_query("Is that blanket to the right of a pillow?")\n    for blanket_patch in blanket_patches:\n        pillow_patches = image_patch.find("pillow")\n        for pillow_patch in pillow_patches:\n            if pillow_patch.horizontal_center > blanket_patch.horizontal_center:\n                return "yes"\n    return "no"\n\n# Are there any bikes or cars?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    have_bike = image_patch.exists("bike")\n    have_car = image_patch.exists("car")\n    if have_bike and have_car:\n        return "no"\n    return bool_to_yesno(not have_bike)\n\n# Is there something known as a bathtub in this picture?\ndef execute_command(image)->str:\n    # contains a relation (in or on), so ask directly\n    image_patch = ImagePatch(image)\n    return image_patch.simple_query("Is there something known as a bathtub in this picture?")\n\n# What type of umbrella is under the man\'s arm?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    man_patches = image_patch.find("man")\n    # Question assumes one man patch\n    if len(man_patches) == 0:\n        # If no man is found, query the image directly\n        return image_patch.simple_query("What type of umbrella is under the man\'s arm?")\n    umbrella_patches = man_patches[0].find("umbrella")\n    # Question assumes only one umbrella patch\n    if len(umbrella_patches) == 0:\n        return "no"\n    return str(umbrella_patches[0].explanation("type of umbrella"))\n\n# What emotion is shown on the woman!S face?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    woman_patches = image_patch.find("woman")\n    # Question assumes only one woman patch\n    if len(woman_patches) == 0:\n        # If no woman is found, query the image directly\n        return image_patch.simple_query("What emotion is shown on the woman!S face?")\n    emotion_patches = woman_patches[0].find("emotion")\n    # Question assumes only one emotion patch\n    if len(emotion_patches) == 0:\n        return "no em', 'from PIL import Image\nfrom vision_functions import find_in_image, simple_qa, verify_property, best_text_match\n\ndef bool_to_yesno(bool_answer: bool)->str:\n    return "yes" if bool_answer else "no"\n\nclass ImagePatch:\n    """A Python class containing a crop of an image centered around a particular object, as well as relevant information.\n    Attributes\n    ----------\n    cropped_image : array_like\n        An array-like of the cropped image taken from the original image.\n    left : int\n        An int describing the position of the left border of the crop\'s bounding box in the original image.\n    lower : int\n        An int describing the position of the bottom border of the crop\'s bounding box in the original image.\n    right : int\n        An int describing the position of the right border of the crop\'s bounding box in the original image.\n    upper : int\n        An int describing the position of the top border of the crop\'s bounding box in the original image.\n\n    Methods\n    -------\n    find(object_name: str)->List[ImagePatch]\n        Returns a list of new ImagePatch objects containing crops of the image centered around any objects found in the image matching the object_name.\n    simple_query(question: str=None)->str\n        Returns the answer to a basic question asked about the image. If no question is provided, returns the answer to "What is this?".\n    exists(object_name: str)->bool\n        Returns True if the object specified by object_name is found in the image, and False otherwise.\n    verify_property(property: str)->bool\n        Returns True if the property is met, and False otherwise.\n    best_text_match(string1: str, string2: str)->str\n        Returns the string that best matches the image.\n    crop(left: int, lower: int, right: int, upper: int)->ImagePatch\n        Returns a new ImagePatch object containing a crop of the image at the given coordinates.\n        """\n\n    def __init__(self, image, left: int=None, lower: int=None, right: int=None, upper: int=None):\n        """Initializes an ImagePatch object by cropping the image at the given coordinates and stores the coordinates as attributes.\n        If no coordinates are provided, the image is left unmodified, and the coordinates are set to the dimensions of the image.\n        Parameters\n        -------\n        image : array_like\n            An array-like of the original image.\n        left : int\n            An int describing the position of the left border of the crop\'s bounding box in the original image.\n        lower : int\n            An int describing the position of the bottom border of the crop\'s bounding box in the original image.\n        right : int\n            An int describing the position of the right border of the crop\'s bounding box in the original image.\n        upper : int\n            An int describing the position of the top border of the crop\'s bounding box in the original image.\n\n        """\n        if left is None and right is None and upper is None and lower is None:\n            self.cropped_image = image\n            self.left = 0\n            self.lower = 0\n            self.right = image.shape[2]  # width\n            self.upper = image.shape[1]  # height\n        else:\n            self.cropped_image = image[:, lower:upper, left:right]\n            self.left = left\n            self.upper = upper\n            self.right = right\n            self.lower = lower\n\n        self.width = self.cropped_image.shape[2]\n        self.height = self.cropped_image.shape[1]\n\n        self.horizontal_center = (self.left + self.right) / 2\n        self.vertical_center = (self.lower + self.upper) / 2\n\n    def find(self, object_name: str)->List["ImagePatch"]:\n        """Returns a new ImagePatch object containing the crop of the image centered around the object specified by object_name.\n        Parameters\n        -------\n        object_name : str\n            A string describing the name of the object to be found in the image.\n        """\n        return find_in_image(self.cropped_image, object_name)\n\n    def simple_query(self, question: str=None)->str:\n        """Returns the answer to a basic question asked about the image. If no question is provided, returns the answer to "What is this?".\n        Parameters\n        -------\n        question : str\n            A string describing the question to be asked.\n\n        Examples\n        -------\n\n        >>> # Which kind of animal is not eating?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     animal_patches = image_patch.find("animal")\n        >>>     for animal_patch in animal_patches:\n        >>>         if not animal_patch.verify_property("animal", "eating"):\n        >>>             return animal_patch.simple_query("What kind of animal is eating?") # crop would include eating so keep it in the query\n        >>>     # If no animal is not eating, query the image directly\n        >>>     return image_patch.simple_query("Which kind of animal is not eating?")\n\n        >>> # What is in front of the horse?\n        >>> # contains a relation (around, next to, on, near, on top of, in front of, behind, etc), so ask directly\n        >>> return image_patch.simple_query("What is in front of the horse?")\n        >>>\n        """\n        return simple_qa(self.cropped_image, question)\n\n    def exists(self, object_name: str)->bool:\n        """Returns True if the object specified by object_name is found in the image, and False otherwise.\n        Parameters\n        -------\n        object_name : str\n            A string describing the name of the object to be found in the image.\n\n        Examples\n        -------\n        >>> # Are there both cakes and gummy bears in the photo?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     is_cake = image_patch.exists("cake")\n        >>>     is_gummy_bear = image_patch.exists("gummy bear")\n        >>>     return bool_to_yesno(is_cake and is_gummy_bear)\n        """\n        return len(self.find(object_name)) > 0\n\n    def verify_property(self, object_name: str, property: str)->bool:\n        """Returns True if the object possesses the property, and False otherwise.\n        Differs from \'exists\' in that it presupposes the existence of the object specified by object_name, instead checking whether the object possesses the property.\n        Parameters\n        -------\n        object_name : str\n            A string describing the name of the object to be found in the image.\n        property : str\n            A string describing the property to be checked.\n\n        Examples\n        -------\n        >>> # Do the letters have blue color?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     letters_patches = image_patch.find("letters")\n        >>>     # Question assumes only one letter patch\n        >>>     if len(letters_patches) == 0:\n        >>>         # If no letters are found, query the image directly\n        >>>         return image_patch.simple_query("Do the letters have blue color?")\n        >>>     return bool_to_yesno(letters_patches[0].verify_property("letters", "blue"))\n        """\n        return verify_property(self.cropped_image, object_name, property)\n\n    def best_text_match(self, option_list: List[str]) -> str:\n        """Returns the string that best matches the image.\n        Parameters\n        -------\n        option_list : str\n            A list with the names of the different options\n        prefix : str\n            A string with the prefixes to append to the options\n\n        Examples\n        -------\n        >>> # Is the cap gold or white?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     cap_patches = image_patch.find("cap")\n        >>>     # Question assumes one cap patch\n        >>>     if len(cap_patches) == 0:\n        >>>         # If no cap is found, query the image directly\n        >>>         return image_patch.simple_query("Is the cap gold or white?")\n        >>>     return cap_patches[0].best_text_match(["gold", "white"])\n        """\n        return best_text_match(self.cropped_image, option_list)\n\n    def crop(self, left: int, lower: int, right: int, upper: int)->"ImagePatch":\n        """Returns a new ImagePatch cropped from the current ImagePatch.\n        Parameters\n        -------\n        left : int\n            The leftmost pixel of the cropped image.\n        lower : int\n            The lowest pixel of the cropped image.\n        right : int\n            The rightmost pixel of the cropped image.\n        upper : int\n            The uppermost pixel of the cropped image.\n        -------\n        """\n        return ImagePatch(self.cropped_image, left, lower, right, upper)\n\n# Examples of using ImagePatch\n# Is there a backpack to the right of the man?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    man_patches = image_patch.find("man")\n    # Question assumes one man patch\n    if len(man_patches) == 0:\n        # If no man is found, query the image directly\n        return image_patch.simple_query("Is there a backpack to the right of the man?")\n    man_patch = man_patches[0]\n    backpack_patches = image_patch.find("backpack")\n    # Question assumes one backpack patch\n    if len(backpack_patches) == 0:\n        return "no"\n    for backpack_patch in backpack_patches:\n        if backpack_patch.horizontal_center > man_patch.horizontal_center:\n            return "yes"\n    return "no"\n\n# In which part is the bread, the bottom or the top?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    bread_patches = image_patch.find("bread")\n    # Question assumes only one bread patch\n    if len(bread_patches) == 0:\n        # If no bread is found, query the image directly\n        return image_patch.simple_query("In which part is the bread, the bottom or the top?")\n    if bread_patches[0].vertical_center < image_patch.vertical_center:\n        return "bottom"\n    else:\n        return "top"\n\n# What type of weather do you see in the photograph?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    return image_patch.simple_query("What type of weather do you see in the photograph?")\n\n# Who is the man staring at?\ndef execute_command(image)->str:\n    # asks for the predicate of a relational verb (staring at), so ask directly\n    image_patch = ImagePatch(image)\n    return image_patch.simple_query("Who is the man staring at?")\n\n# What toy is wearing a shirt?\ndef execute_command(image)->str:\n    # not a relational verb so go step by step\n    image_patch = ImagePatch(image)\n    toy_patches = image_patch.find("toy")\n    # Question assumes only one toy patch\n    if len(toy_patches) == 0:\n        # If no toy is found, query the image directly\n        return image_patch.simple_query("What toy is wearing a shirt?")\n    for toy_patch in toy_patches:\n        is_wearing_shirt = (toy_patch.simple_query("Is the toy wearing a shirt?") == "yes")\n        if is_wearing_shirt:\n            return toy_patch.simple_query("What toy is wearing a shirt?") # crop would include the shirt so keep it in the query\n    # If no toy is wearing a shirt, pick the first toy\n    return toy_patches[0].simple_query("What toy is wearing a shirt?")\n\n# What is behind the pole?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    # contains a relation (around, next to, on, near, on top of, in front of, behind, etc), so ask directly\n    return image_patch.simple_query("What is behind the pole?")\n\n# Are there bagels or lemons?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    is_bagel = image_patch.exists("bagel")\n    is_lemon = image_patch.exists("lemon")\n    return bool_to_yesno(is_bagel or is_lemon)\n\n# Is that blanket to the right of a pillow?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    blanket_patches = image_patch.find("blanket")\n    # Question assumes only one blanket patch\n    if len(blanket_patches) == 0:\n        # If no blanket is found, query the image directly\n        return image_patch.simple_query("Is that blanket to the right of a pillow?")\n    for blanket_patch in blanket_patches:\n        pillow_patches = image_patch.find("pillow")\n        for pillow_patch in pillow_patches:\n            if pillow_patch.horizontal_center > blanket_patch.horizontal_center:\n                return "yes"\n    return "no"\n\n# What is the man guiding?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    man_patches = image_patch.find("man")\n    # Question assumes only one man patch\n    if len(man_patches) == 0:\n        # If no man is found, query the image directly\n        return image_patch.simple_query("What is the man guiding?")\n    guiding_patches = man_patches[0].find("guiding")\n    # Question assumes only one guiding patch\n    if len(guiding_patches) == 0:\n        # If no guiding is found, query the image directly\n        return image_patch.simple_query("What is the man guiding?")\n    return guiding_patches[0].best_text_match(["sea", "tree", "trail"])\n\n# Is the bird flying south or north?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    bird_patches = image_patch.find("bird")\n    # Question assumes only one bird patch\n    if len(bird_patches) == 0:\n        # If no bird is found, query the image directly\n        return image_patch.simple_query("Is the bird flying south or north?")\n    is_flying_north = (bird_patches[0].simple_query("Is the bird flying north?") == "yes")\n    return "north" if is_flying_north else "south"\n\n# Does the dog like cheese?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    dog_patches = image_patch.find("dog")\n    # Question assumes only one dog patch\n    if len(dog_patches) == 0:\n        # If no dog is found, query the image directly\n        return image_patch.simple_query("Does the dog like cheese?")\n    is_liking_cheese = (dog_patches[0].simple_query("Sub-question 1: Does the dog like cheese?") == "yes")\n    if is_liking_cheese:\n        return image_patch.simple_query("Sub-question', 'from PIL import Image\nfrom vision_functions import find_in_image, simple_qa, verify_property, best_text_match\n\ndef bool_to_yesno(bool_answer: bool)->str:\n    return "yes" if bool_answer else "no"\n\nclass ImagePatch:\n    """A Python class containing a crop of an image centered around a particular object, as well as relevant information.\n    Attributes\n    ----------\n    cropped_image : array_like\n        An array-like of the cropped image taken from the original image.\n    left : int\n        An int describing the position of the left border of the crop\'s bounding box in the original image.\n    lower : int\n        An int describing the position of the bottom border of the crop\'s bounding box in the original image.\n    right : int\n        An int describing the position of the right border of the crop\'s bounding box in the original image.\n    upper : int\n        An int describing the position of the top border of the crop\'s bounding box in the original image.\n\n    Methods\n    -------\n    find(object_name: str)->List[ImagePatch]\n        Returns a list of new ImagePatch objects containing crops of the image centered around any objects found in the image matching the object_name.\n    simple_query(question: str=None)->str\n        Returns the answer to a basic question asked about the image. If no question is provided, returns the answer to "What is this?".\n    exists(object_name: str)->bool\n        Returns True if the object specified by object_name is found in the image, and False otherwise.\n    verify_property(property: str)->bool\n        Returns True if the property is met, and False otherwise.\n    best_text_match(string1: str, string2: str)->str\n        Returns the string that best matches the image.\n    crop(left: int, lower: int, right: int, upper: int)->ImagePatch\n        Returns a new ImagePatch object containing a crop of the image at the given coordinates.\n        """\n\n    def __init__(self, image, left: int=None, lower: int=None, right: int=None, upper: int=None):\n        """Initializes an ImagePatch object by cropping the image at the given coordinates and stores the coordinates as attributes.\n        If no coordinates are provided, the image is left unmodified, and the coordinates are set to the dimensions of the image.\n        Parameters\n        -------\n        image : array_like\n            An array-like of the original image.\n        left : int\n            An int describing the position of the left border of the crop\'s bounding box in the original image.\n        lower : int\n            An int describing the position of the bottom border of the crop\'s bounding box in the original image.\n        right : int\n            An int describing the position of the right border of the crop\'s bounding box in the original image.\n        upper : int\n            An int describing the position of the top border of the crop\'s bounding box in the original image.\n\n        """\n        if left is None and right is None and upper is None and lower is None:\n            self.cropped_image = image\n            self.left = 0\n            self.lower = 0\n            self.right = image.shape[2]  # width\n            self.upper = image.shape[1]  # height\n        else:\n            self.cropped_image = image[:, lower:upper, left:right]\n            self.left = left\n            self.upper = upper\n            self.right = right\n            self.lower = lower\n\n        self.width = self.cropped_image.shape[2]\n        self.height = self.cropped_image.shape[1]\n\n        self.horizontal_center = (self.left + self.right) / 2\n        self.vertical_center = (self.lower + self.upper) / 2\n\n    def find(self, object_name: str)->List["ImagePatch"]:\n        """Returns a new ImagePatch object containing the crop of the image centered around the object specified by object_name.\n        Parameters\n        -------\n        object_name : str\n            A string describing the name of the object to be found in the image.\n        """\n        return find_in_image(self.cropped_image, object_name)\n\n    def simple_query(self, question: str=None)->str:\n        """Returns the answer to a basic question asked about the image. If no question is provided, returns the answer to "What is this?".\n        Parameters\n        -------\n        question : str\n            A string describing the question to be asked.\n\n        Examples\n        -------\n\n        >>> # Which kind of animal is not eating?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     animal_patches = image_patch.find("animal")\n        >>>     for animal_patch in animal_patches:\n        >>>         if not animal_patch.verify_property("animal", "eating"):\n        >>>             return animal_patch.simple_query("What kind of animal is eating?") # crop would include eating so keep it in the query\n        >>>     # If no animal is not eating, query the image directly\n        >>>     return image_patch.simple_query("Which kind of animal is not eating?")\n\n        >>> # What is in front of the horse?\n        >>> # contains a relation (around, next to, on, near, on top of, in front of, behind, etc), so ask directly\n        >>> return image_patch.simple_query("What is in front of the horse?")\n        >>>\n        """\n        return simple_qa(self.cropped_image, question)\n\n    def exists(self, object_name: str)->bool:\n        """Returns True if the object specified by object_name is found in the image, and False otherwise.\n        Parameters\n        -------\n        object_name : str\n            A string describing the name of the object to be found in the image.\n\n        Examples\n        -------\n        >>> # Are there both cakes and gummy bears in the photo?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     is_cake = image_patch.exists("cake")\n        >>>     is_gummy_bear = image_patch.exists("gummy bear")\n        >>>     return bool_to_yesno(is_cake and is_gummy_bear)\n        """\n        return len(self.find(object_name)) > 0\n\n    def verify_property(self, object_name: str, property: str)->bool:\n        """Returns True if the object possesses the property, and False otherwise.\n        Differs from \'exists\' in that it presupposes the existence of the object specified by object_name, instead checking whether the object possesses the property.\n        Parameters\n        -------\n        object_name : str\n            A string describing the name of the object to be found in the image.\n        property : str\n            A string describing the property to be checked.\n\n        Examples\n        -------\n        >>> # Do the letters have blue color?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     letters_patches = image_patch.find("letters")\n        >>>     # Question assumes only one letter patch\n        >>>     if len(letters_patches) == 0:\n        >>>         # If no letters are found, query the image directly\n        >>>         return image_patch.simple_query("Do the letters have blue color?")\n        >>>     return bool_to_yesno(letters_patches[0].verify_property("letters", "blue"))\n        """\n        return verify_property(self.cropped_image, object_name, property)\n\n    def best_text_match(self, option_list: List[str]) -> str:\n        """Returns the string that best matches the image.\n        Parameters\n        -------\n        option_list : str\n            A list with the names of the different options\n        prefix : str\n            A string with the prefixes to append to the options\n\n        Examples\n        -------\n        >>> # Is the cap gold or white?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     cap_patches = image_patch.find("cap")\n        >>>     # Question assumes one cap patch\n        >>>     if len(cap_patches) == 0:\n        >>>         # If no cap is found, query the image directly\n        >>>         return image_patch.simple_query("Is the cap gold or white?")\n        >>>     return cap_patches[0].best_text_match(["gold", "white"])\n        """\n        return best_text_match(self.cropped_image, option_list)\n\n    def crop(self, left: int, lower: int, right: int, upper: int)->"ImagePatch":\n        """Returns a new ImagePatch cropped from the current ImagePatch.\n        Parameters\n        -------\n        left : int\n            The leftmost pixel of the cropped image.\n        lower : int\n            The lowest pixel of the cropped image.\n        right : int\n            The rightmost pixel of the cropped image.\n        upper : int\n            The uppermost pixel of the cropped image.\n        -------\n        """\n        return ImagePatch(self.cropped_image, left, lower, right, upper)\n\n# Examples of using ImagePatch\n# Is there a backpack to the right of the man?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    man_patches = image_patch.find("man")\n    # Question assumes one man patch\n    if len(man_patches) == 0:\n        # If no man is found, query the image directly\n        return image_patch.simple_query("Is there a backpack to the right of the man?")\n    man_patch = man_patches[0]\n    backpack_patches = image_patch.find("backpack")\n    # Question assumes one backpack patch\n    if len(backpack_patches) == 0:\n        return "no"\n    for backpack_patch in backpack_patches:\n        if backpack_patch.horizontal_center > man_patch.horizontal_center:\n            return "yes"\n    return "no"\n\n# In which part is the bread, the bottom or the top?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    bread_patches = image_patch.find("bread")\n    # Question assumes only one bread patch\n    if len(bread_patches) == 0:\n        # If no bread is found, query the image directly\n        return image_patch.simple_query("In which part is the bread, the bottom or the top?")\n    if bread_patches[0].vertical_center < image_patch.vertical_center:\n        return "bottom"\n    else:\n        return "top"\n\n# What type of weather do you see in the photograph?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    return image_patch.simple_query("What type of weather do you see in the photograph?")\n\n# Who is the man staring at?\ndef execute_command(image)->str:\n    # asks for the predicate of a relational verb (staring at), so ask directly\n    image_patch = ImagePatch(image)\n    return image_patch.simple_query("Who is the man staring at?")\n\n# What toy is wearing a shirt?\ndef execute_command(image)->str:\n    # not a relational verb so go step by step\n    image_patch = ImagePatch(image)\n    toy_patches = image_patch.find("toy")\n    # Question assumes only one toy patch\n    if len(toy_patches) == 0:\n        # If no toy is found, query the image directly\n        return image_patch.simple_query("What toy is wearing a shirt?")\n    for toy_patch in toy_patches:\n        is_wearing_shirt = (toy_patch.simple_query("Is the toy wearing a shirt?") == "yes")\n        if is_wearing_shirt:\n            return toy_patch.simple_query("What toy is wearing a shirt?") # crop would include the shirt so keep it in the query\n    # If no toy is wearing a shirt, pick the first toy\n    return toy_patches[0].simple_query("What toy is wearing a shirt?")\n\n# What is behind the pole?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    # contains a relation (around, next to, on, near, on top of, in front of, behind, etc), so ask directly\n    return image_patch.simple_query("What is behind the pole?")\n\n# Are there bagels or lemons?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    is_bagel = image_patch.exists("bagel")\n    is_lemon = image_patch.exists("lemon")\n    return bool_to_yesno(is_bagel or is_lemon)\n\n# Is that blanket to the right of a pillow?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    blanket_patches = image_patch.find("blanket")\n    # Question assumes only one blanket patch\n    if len(blanket_patches) == 0:\n        # If no blanket is found, query the image directly\n        return image_patch.simple_query("Is that blanket to the right of a pillow?")\n    for blanket_patch in blanket_patches:\n        pillow_patches = image_patch.find("pillow")\n        for pillow_patch in pillow_patches:\n            if pillow_patch.horizontal_center > blanket_patch.horizontal_center:\n                return "yes"\n    return "no"\n\n# What is the avocado on?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    avocado_patches = image_patch.find("avocado")\n    # Question assumes only one avocado patch\n    if len(avocado_patches) == 0:\n        # If no avocado is found, query the image directly\n        return image_patch.simple_query("What is the avocado on?")\n    return avocado_patches[0].simple_query("What is the avocado on?") # crop would include \'avocado\' so keep it in the query\n\n# Does the elephant have two trunks and one tusk?\n# if I only answer yes/no I\'ll get yes/no questions, so use read specs to search for 2 trunks and 1 tusk\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    elephant_patches = image_patch.find("elephant")\n    # Question assumes only one elephant patch\n    if len(elephant_patches) == 0:\n        # If no elephant is found, query the image directly\n        return image_patch.simple_query("Does the elephant have two trunks and one tusk?")\n    attributes = {"2 trunks": 0, "1 tusk": 0}\n    image_patch = elephant_patches[0]\n    # Assume only one patch and not searching max of 3\n    for attribute in attributes.keys():\n        if image_patch.verify_property("trunk", attribute):\n            attributes[attribute] += 1\n    return image_patch.best_text_match(attributes.keys())\n', 'from PIL import Image\nfrom vision_functions import find_in_image, simple_qa, verify_property, best_text_match\n\ndef bool_to_yesno(bool_answer: bool)->str:\n    return "yes" if bool_answer else "no"\n\nclass ImagePatch:\n    """A Python class containing a crop of an image centered around a particular object, as well as relevant information.\n    Attributes\n    ----------\n    cropped_image : array_like\n        An array-like of the cropped image taken from the original image.\n    left : int\n        An int describing the position of the left border of the crop\'s bounding box in the original image.\n    lower : int\n        An int describing the position of the bottom border of the crop\'s bounding box in the original image.\n    right : int\n        An int describing the position of the right border of the crop\'s bounding box in the original image.\n    upper : int\n        An int describing the position of the top border of the crop\'s bounding box in the original image.\n\n    Methods\n    -------\n    find(object_name: str)->List[ImagePatch]\n        Returns a list of new ImagePatch objects containing crops of the image centered around any objects found in the image matching the object_name.\n    simple_query(question: str=None)->str\n        Returns the answer to a basic question asked about the image. If no question is provided, returns the answer to "What is this?".\n    exists(object_name: str)->bool\n        Returns True if the object specified by object_name is found in the image, and False otherwise.\n    verify_property(property: str)->bool\n        Returns True if the property is met, and False otherwise.\n    best_text_match(string1: str, string2: str)->str\n        Returns the string that best matches the image.\n    crop(left: int, lower: int, right: int, upper: int)->ImagePatch\n        Returns a new ImagePatch object containing a crop of the image at the given coordinates.\n        """\n\n    def __init__(self, image, left: int=None, lower: int=None, right: int=None, upper: int=None):\n        """Initializes an ImagePatch object by cropping the image at the given coordinates and stores the coordinates as attributes.\n        If no coordinates are provided, the image is left unmodified, and the coordinates are set to the dimensions of the image.\n        Parameters\n        -------\n        image : array_like\n            An array-like of the original image.\n        left : int\n            An int describing the position of the left border of the crop\'s bounding box in the original image.\n        lower : int\n            An int describing the position of the bottom border of the crop\'s bounding box in the original image.\n        right : int\n            An int describing the position of the right border of the crop\'s bounding box in the original image.\n        upper : int\n            An int describing the position of the top border of the crop\'s bounding box in the original image.\n\n        """\n        if left is None and right is None and upper is None and lower is None:\n            self.cropped_image = image\n            self.left = 0\n            self.lower = 0\n            self.right = image.shape[2]  # width\n            self.upper = image.shape[1]  # height\n        else:\n            self.cropped_image = image[:, lower:upper, left:right]\n            self.left = left\n            self.upper = upper\n            self.right = right\n            self.lower = lower\n\n        self.width = self.cropped_image.shape[2]\n        self.height = self.cropped_image.shape[1]\n\n        self.horizontal_center = (self.left + self.right) / 2\n        self.vertical_center = (self.lower + self.upper) / 2\n\n    def find(self, object_name: str)->List["ImagePatch"]:\n        """Returns a new ImagePatch object containing the crop of the image centered around the object specified by object_name.\n        Parameters\n        -------\n        object_name : str\n            A string describing the name of the object to be found in the image.\n        """\n        return find_in_image(self.cropped_image, object_name)\n\n    def simple_query(self, question: str=None)->str:\n        """Returns the answer to a basic question asked about the image. If no question is provided, returns the answer to "What is this?".\n        Parameters\n        -------\n        question : str\n            A string describing the question to be asked.\n\n        Examples\n        -------\n\n        >>> # Which kind of animal is not eating?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     animal_patches = image_patch.find("animal")\n        >>>     for animal_patch in animal_patches:\n        >>>         if not animal_patch.verify_property("animal", "eating"):\n        >>>             return animal_patch.simple_query("What kind of animal is eating?") # crop would include eating so keep it in the query\n        >>>     # If no animal is not eating, query the image directly\n        >>>     return image_patch.simple_query("Which kind of animal is not eating?")\n\n        >>> # What is in front of the horse?\n        >>> # contains a relation (around, next to, on, near, on top of, in front of, behind, etc), so ask directly\n        >>> return image_patch.simple_query("What is in front of the horse?")\n        >>>\n        """\n        return simple_qa(self.cropped_image, question)\n\n    def exists(self, object_name: str)->bool:\n        """Returns True if the object specified by object_name is found in the image, and False otherwise.\n        Parameters\n        -------\n        object_name : str\n            A string describing the name of the object to be found in the image.\n\n        Examples\n        -------\n        >>> # Are there both cakes and gummy bears in the photo?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     is_cake = image_patch.exists("cake")\n        >>>     is_gummy_bear = image_patch.exists("gummy bear")\n        >>>     return bool_to_yesno(is_cake and is_gummy_bear)\n        """\n        return len(self.find(object_name)) > 0\n\n    def verify_property(self, object_name: str, property: str)->bool:\n        """Returns True if the object possesses the property, and False otherwise.\n        Differs from \'exists\' in that it presupposes the existence of the object specified by object_name, instead checking whether the object possesses the property.\n        Parameters\n        -------\n        object_name : str\n            A string describing the name of the object to be found in the image.\n        property : str\n            A string describing the property to be checked.\n\n        Examples\n        -------\n        >>> # Do the letters have blue color?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     letters_patches = image_patch.find("letters")\n        >>>     # Question assumes only one letter patch\n        >>>     if len(letters_patches) == 0:\n        >>>         # If no letters are found, query the image directly\n        >>>         return image_patch.simple_query("Do the letters have blue color?")\n        >>>     return bool_to_yesno(letters_patches[0].verify_property("letters", "blue"))\n        """\n        return verify_property(self.cropped_image, object_name, property)\n\n    def best_text_match(self, option_list: List[str]) -> str:\n        """Returns the string that best matches the image.\n        Parameters\n        -------\n        option_list : str\n            A list with the names of the different options\n        prefix : str\n            A string with the prefixes to append to the options\n\n        Examples\n        -------\n        >>> # Is the cap gold or white?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     cap_patches = image_patch.find("cap")\n        >>>     # Question assumes one cap patch\n        >>>     if len(cap_patches) == 0:\n        >>>         # If no cap is found, query the image directly\n        >>>         return image_patch.simple_query("Is the cap gold or white?")\n        >>>     return cap_patches[0].best_text_match(["gold", "white"])\n        """\n        return best_text_match(self.cropped_image, option_list)\n\n    def crop(self, left: int, lower: int, right: int, upper: int)->"ImagePatch":\n        """Returns a new ImagePatch cropped from the current ImagePatch.\n        Parameters\n        -------\n        left : int\n            The leftmost pixel of the cropped image.\n        lower : int\n            The lowest pixel of the cropped image.\n        right : int\n            The rightmost pixel of the cropped image.\n        upper : int\n            The uppermost pixel of the cropped image.\n        -------\n        """\n        return ImagePatch(self.cropped_image, left, lower, right, upper)\n\n# Examples of using ImagePatch\n# Is there a backpack to the right of the man?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    man_patches = image_patch.find("man")\n    # Question assumes one man patch\n    if len(man_patches) == 0:\n        # If no man is found, query the image directly\n        return image_patch.simple_query("Is there a backpack to the right of the man?")\n    man_patch = man_patches[0]\n    backpack_patches = image_patch.find("backpack")\n    # Question assumes one backpack patch\n    if len(backpack_patches) == 0:\n        return "no"\n    for backpack_patch in backpack_patches:\n        if backpack_patch.horizontal_center > man_patch.horizontal_center:\n            return "yes"\n    return "no"\n\n# In which part is the bread, the bottom or the top?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    bread_patches = image_patch.find("bread")\n    # Question assumes only one bread patch\n    if len(bread_patches) == 0:\n        # If no bread is found, query the image directly\n        return image_patch.simple_query("In which part is the bread, the bottom or the top?")\n    if bread_patches[0].vertical_center < image_patch.vertical_center:\n        return "bottom"\n    else:\n        return "top"\n\n# What type of weather do you see in the photograph?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    return image_patch.simple_query("What type of weather do you see in the photograph?")\n\n# Who is the man staring at?\ndef execute_command(image)->str:\n    # asks for the predicate of a relational verb (staring at), so ask directly\n    image_patch = ImagePatch(image)\n    return image_patch.simple_query("Who is the man staring at?")\n\n# What toy is wearing a shirt?\ndef execute_command(image)->str:\n    # not a relational verb so go step by step\n    image_patch = ImagePatch(image)\n    toy_patches = image_patch.find("toy")\n    # Question assumes only one toy patch\n    if len(toy_patches) == 0:\n        # If no toy is found, query the image directly\n        return image_patch.simple_query("What toy is wearing a shirt?")\n    for toy_patch in toy_patches:\n        is_wearing_shirt = (toy_patch.simple_query("Is the toy wearing a shirt?") == "yes")\n        if is_wearing_shirt:\n            return toy_patch.simple_query("What toy is wearing a shirt?") # crop would include the shirt so keep it in the query\n    # If no toy is wearing a shirt, pick the first toy\n    return toy_patches[0].simple_query("What toy is wearing a shirt?")\n\n# What is behind the pole?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    # contains a relation (around, next to, on, near, on top of, in front of, behind, etc), so ask directly\n    return image_patch.simple_query("What is behind the pole?")\n\n# Are there bagels or lemons?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    is_bagel = image_patch.exists("bagel")\n    is_lemon = image_patch.exists("lemon")\n    return bool_to_yesno(is_bagel or is_lemon)\n\n# Is that blanket to the right of a pillow?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    blanket_patches = image_patch.find("blanket")\n    # Question assumes only one blanket patch\n    if len(blanket_patches) == 0:\n        # If no blanket is found, query the image directly\n        return image_patch.simple_query("Is that blanket to the right of a pillow?")\n    for blanket_patch in blanket_patches:\n        pillow_patches = image_patch.find("pillow")\n        for pillow_patch in pillow_patches:\n            if pillow_patch.horizontal_center > blanket_patch.horizontal_center:\n                return "yes"\n    return "no"\n\n# What is the color of the shirt the woman is wearing?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    patches_with_shirt = image_patch.find("shirt")\n    # Question assumes only one shirt patch\n    if len(patches_with_shirt) == 0:\n        # If no shirt could be found, query the image directly\n        return image_patch.simple_query("What is the color of the shirt the woman is wearing?")\n    return patches_with_shirt[0].simple_query("What is the color of the shirt the woman is wearing?")\n\n# Is either man eating soup or are they watching TV?\ndef execute_command(image)->str:\n    # checks for both the existance of the eating predicate and for the eating predicate\n    # efficient because both checks can be done together\n    image_patch = ImagePatch(image)\n    man1_patches = image_patch.find("man")\n    # Question assumes only one man patch\n    if len(man1_patches) == 0:\n        # If no man is found, query the image directly\n        return image_patch.simple_query("Is either man eating soup or are they watching TV?")\n    comp = "eating soup"\n    man1_result = image_patch.veri_property("man", comp)\n    if man1_result:\n        return bool_to_yesno(man1_result)\n    comp = "watching TV"\n    man1_result = image_patch.veri_property("man", comp)\n    # Question assumes only one man patch\n    return bool_to_yesno(man1_result)\n\n# Is that pineapple (to the right) red?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    pineapple_patches = image_patch.find("pineapple")\n    # Question assumes only one pineapple patch\n    if len(pineapple_patches) == 0:\n        # If no pineapple is found, query the image directly\n        return image_patch.simple_query("Is that pineapple (to the right) red?")\n    for pineapple_patch in pine', 'from PIL import Image\nfrom vision_functions import find_in_image, simple_qa, verify_property, best_text_match\n\ndef bool_to_yesno(bool_answer: bool)->str:\n    return "yes" if bool_answer else "no"\n\nclass ImagePatch:\n    """A Python class containing a crop of an image centered around a particular object, as well as relevant information.\n    Attributes\n    ----------\n    cropped_image : array_like\n        An array-like of the cropped image taken from the original image.\n    left : int\n        An int describing the position of the left border of the crop\'s bounding box in the original image.\n    lower : int\n        An int describing the position of the bottom border of the crop\'s bounding box in the original image.\n    right : int\n        An int describing the position of the right border of the crop\'s bounding box in the original image.\n    upper : int\n        An int describing the position of the top border of the crop\'s bounding box in the original image.\n\n    Methods\n    -------\n    find(object_name: str)->List[ImagePatch]\n        Returns a list of new ImagePatch objects containing crops of the image centered around any objects found in the image matching the object_name.\n    simple_query(question: str=None)->str\n        Returns the answer to a basic question asked about the image. If no question is provided, returns the answer to "What is this?".\n    exists(object_name: str)->bool\n        Returns True if the object specified by object_name is found in the image, and False otherwise.\n    verify_property(property: str)->bool\n        Returns True if the property is met, and False otherwise.\n    best_text_match(string1: str, string2: str)->str\n        Returns the string that best matches the image.\n    crop(left: int, lower: int, right: int, upper: int)->ImagePatch\n        Returns a new ImagePatch object containing a crop of the image at the given coordinates.\n        """\n\n    def __init__(self, image, left: int=None, lower: int=None, right: int=None, upper: int=None):\n        """Initializes an ImagePatch object by cropping the image at the given coordinates and stores the coordinates as attributes.\n        If no coordinates are provided, the image is left unmodified, and the coordinates are set to the dimensions of the image.\n        Parameters\n        -------\n        image : array_like\n            An array-like of the original image.\n        left : int\n            An int describing the position of the left border of the crop\'s bounding box in the original image.\n        lower : int\n            An int describing the position of the bottom border of the crop\'s bounding box in the original image.\n        right : int\n            An int describing the position of the right border of the crop\'s bounding box in the original image.\n        upper : int\n            An int describing the position of the top border of the crop\'s bounding box in the original image.\n\n        """\n        if left is None and right is None and upper is None and lower is None:\n            self.cropped_image = image\n            self.left = 0\n            self.lower = 0\n            self.right = image.shape[2]  # width\n            self.upper = image.shape[1]  # height\n        else:\n            self.cropped_image = image[:, lower:upper, left:right]\n            self.left = left\n            self.upper = upper\n            self.right = right\n            self.lower = lower\n\n        self.width = self.cropped_image.shape[2]\n        self.height = self.cropped_image.shape[1]\n\n        self.horizontal_center = (self.left + self.right) / 2\n        self.vertical_center = (self.lower + self.upper) / 2\n\n    def find(self, object_name: str)->List["ImagePatch"]:\n        """Returns a new ImagePatch object containing the crop of the image centered around the object specified by object_name.\n        Parameters\n        -------\n        object_name : str\n            A string describing the name of the object to be found in the image.\n        """\n        return find_in_image(self.cropped_image, object_name)\n\n    def simple_query(self, question: str=None)->str:\n        """Returns the answer to a basic question asked about the image. If no question is provided, returns the answer to "What is this?".\n        Parameters\n        -------\n        question : str\n            A string describing the question to be asked.\n\n        Examples\n        -------\n\n        >>> # Which kind of animal is not eating?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     animal_patches = image_patch.find("animal")\n        >>>     for animal_patch in animal_patches:\n        >>>         if not animal_patch.verify_property("animal", "eating"):\n        >>>             return animal_patch.simple_query("What kind of animal is eating?") # crop would include eating so keep it in the query\n        >>>     # If no animal is not eating, query the image directly\n        >>>     return image_patch.simple_query("Which kind of animal is not eating?")\n\n        >>> # What is in front of the horse?\n        >>> # contains a relation (around, next to, on, near, on top of, in front of, behind, etc), so ask directly\n        >>> return image_patch.simple_query("What is in front of the horse?")\n        >>>\n        """\n        return simple_qa(self.cropped_image, question)\n\n    def exists(self, object_name: str)->bool:\n        """Returns True if the object specified by object_name is found in the image, and False otherwise.\n        Parameters\n        -------\n        object_name : str\n            A string describing the name of the object to be found in the image.\n\n        Examples\n        -------\n        >>> # Are there both cakes and gummy bears in the photo?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     is_cake = image_patch.exists("cake")\n        >>>     is_gummy_bear = image_patch.exists("gummy bear")\n        >>>     return bool_to_yesno(is_cake and is_gummy_bear)\n        """\n        return len(self.find(object_name)) > 0\n\n    def verify_property(self, object_name: str, property: str)->bool:\n        """Returns True if the object possesses the property, and False otherwise.\n        Differs from \'exists\' in that it presupposes the existence of the object specified by object_name, instead checking whether the object possesses the property.\n        Parameters\n        -------\n        object_name : str\n            A string describing the name of the object to be found in the image.\n        property : str\n            A string describing the property to be checked.\n\n        Examples\n        -------\n        >>> # Do the letters have blue color?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     letters_patches = image_patch.find("letters")\n        >>>     # Question assumes only one letter patch\n        >>>     if len(letters_patches) == 0:\n        >>>         # If no letters are found, query the image directly\n        >>>         return image_patch.simple_query("Do the letters have blue color?")\n        >>>     return bool_to_yesno(letters_patches[0].verify_property("letters", "blue"))\n        """\n        return verify_property(self.cropped_image, object_name, property)\n\n    def best_text_match(self, option_list: List[str]) -> str:\n        """Returns the string that best matches the image.\n        Parameters\n        -------\n        option_list : str\n            A list with the names of the different options\n        prefix : str\n            A string with the prefixes to append to the options\n\n        Examples\n        -------\n        >>> # Is the cap gold or white?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     cap_patches = image_patch.find("cap")\n        >>>     # Question assumes one cap patch\n        >>>     if len(cap_patches) == 0:\n        >>>         # If no cap is found, query the image directly\n        >>>         return image_patch.simple_query("Is the cap gold or white?")\n        >>>     return cap_patches[0].best_text_match(["gold", "white"])\n        """\n        return best_text_match(self.cropped_image, option_list)\n\n    def crop(self, left: int, lower: int, right: int, upper: int)->"ImagePatch":\n        """Returns a new ImagePatch cropped from the current ImagePatch.\n        Parameters\n        -------\n        left : int\n            The leftmost pixel of the cropped image.\n        lower : int\n            The lowest pixel of the cropped image.\n        right : int\n            The rightmost pixel of the cropped image.\n        upper : int\n            The uppermost pixel of the cropped image.\n        -------\n        """\n        return ImagePatch(self.cropped_image, left, lower, right, upper)\n\n# Examples of using ImagePatch\n# Is there a backpack to the right of the man?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    man_patches = image_patch.find("man")\n    # Question assumes one man patch\n    if len(man_patches) == 0:\n        # If no man is found, query the image directly\n        return image_patch.simple_query("Is there a backpack to the right of the man?")\n    man_patch = man_patches[0]\n    backpack_patches = image_patch.find("backpack")\n    # Question assumes one backpack patch\n    if len(backpack_patches) == 0:\n        return "no"\n    for backpack_patch in backpack_patches:\n        if backpack_patch.horizontal_center > man_patch.horizontal_center:\n            return "yes"\n    return "no"\n\n# In which part is the bread, the bottom or the top?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    bread_patches = image_patch.find("bread")\n    # Question assumes only one bread patch\n    if len(bread_patches) == 0:\n        # If no bread is found, query the image directly\n        return image_patch.simple_query("In which part is the bread, the bottom or the top?")\n    if bread_patches[0].vertical_center < image_patch.vertical_center:\n        return "bottom"\n    else:\n        return "top"\n\n# What type of weather do you see in the photograph?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    return image_patch.simple_query("What type of weather do you see in the photograph?")\n\n# Who is the man staring at?\ndef execute_command(image)->str:\n    # asks for the predicate of a relational verb (staring at), so ask directly\n    image_patch = ImagePatch(image)\n    return image_patch.simple_query("Who is the man staring at?")\n\n# What toy is wearing a shirt?\ndef execute_command(image)->str:\n    # not a relational verb so go step by step\n    image_patch = ImagePatch(image)\n    toy_patches = image_patch.find("toy")\n    # Question assumes only one toy patch\n    if len(toy_patches) == 0:\n        # If no toy is found, query the image directly\n        return image_patch.simple_query("What toy is wearing a shirt?")\n    for toy_patch in toy_patches:\n        is_wearing_shirt = (toy_patch.simple_query("Is the toy wearing a shirt?") == "yes")\n        if is_wearing_shirt:\n            return toy_patch.simple_query("What toy is wearing a shirt?") # crop would include the shirt so keep it in the query\n    # If no toy is wearing a shirt, pick the first toy\n    return toy_patches[0].simple_query("What toy is wearing a shirt?")\n\n# What is behind the pole?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    # contains a relation (around, next to, on, near, on top of, in front of, behind, etc), so ask directly\n    return image_patch.simple_query("What is behind the pole?")\n\n# Are there bagels or lemons?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    is_bagel = image_patch.exists("bagel")\n    is_lemon = image_patch.exists("lemon")\n    return bool_to_yesno(is_bagel or is_lemon)\n\n# Is that blanket to the right of a pillow?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    blanket_patches = image_patch.find("blanket")\n    # Question assumes only one blanket patch\n    if len(blanket_patches) == 0:\n        # If no blanket is found, query the image directly\n        return image_patch.simple_query("Is that blanket to the right of a pillow?")\n    for blanket_patch in blanket_patches:\n        pillow_patches = image_patch.find("pillow")\n        for pillow_patch in pillow_patches:\n            if pillow_patch.horizontal_center > blanket_patch.horizontal_center:\n                return "yes"\n    return "no"\n\n# What cooking utensil is left of the oven?\ndef execute_command(image)->str:\n    # From the question explain about in your "How do I ask it a question I wrote a crap description for myself?" comment above\n    image_patch = ImagePatch(image)\n    cooking_utensil_patches = image_patch.find("cooking_utensil")\n    # Question assumes only one cooking_utensil patch\n    if len(cooking_utensil_patches) == 0:\n        # If no cooking_utensil is found, query the image directly\n        return image_patch.simple_query("What cooking utensil is left of the oven?")\n    for cooking_utensil_patch in cooking_utensil_patches:\n        oven_patches = image_patch.find("oven")\n        for oven_patch in oven_patches:\n            if cooking_utensil_patch.horizontal_center < oven_patch.horizontal_center:\n                return bool_to_yesno((cooking_utensil_patch.simple_query("Is a knife?") == "yes") or ((cooking_utensil_patch.simple_query("Is a spatula?") == "yes") or (cooking_utensil_patch.simple_query("Is a stirring machine?") == "yes")))\n    return "yes"\n\n# What land is green?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    return image_patch.simple_query("What land is green?")\n\n# Is the bottle full?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    return image_patch.simple_query("Is the bottle full?")\n\n# Is that bird perched at the top of the tree?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    bird_patches = image_patch.find("bird")\n    # Question assumes only one bird patch\n    if len(bird_patches) == 0:\n        # If no bird is found, query the image directly\n        return image_patch.simple_query("Is that bird perched at', 'from PIL import Image\nfrom vision_functions import find_in_image, simple_qa, verify_property, best_text_match\n\ndef bool_to_yesno(bool_answer: bool)->str:\n    return "yes" if bool_answer else "no"\n\nclass ImagePatch:\n    """A Python class containing a crop of an image centered around a particular object, as well as relevant information.\n    Attributes\n    ----------\n    cropped_image : array_like\n        An array-like of the cropped image taken from the original image.\n    left : int\n        An int describing the position of the left border of the crop\'s bounding box in the original image.\n    lower : int\n        An int describing the position of the bottom border of the crop\'s bounding box in the original image.\n    right : int\n        An int describing the position of the right border of the crop\'s bounding box in the original image.\n    upper : int\n        An int describing the position of the top border of the crop\'s bounding box in the original image.\n\n    Methods\n    -------\n    find(object_name: str)->List[ImagePatch]\n        Returns a list of new ImagePatch objects containing crops of the image centered around any objects found in the image matching the object_name.\n    simple_query(question: str=None)->str\n        Returns the answer to a basic question asked about the image. If no question is provided, returns the answer to "What is this?".\n    exists(object_name: str)->bool\n        Returns True if the object specified by object_name is found in the image, and False otherwise.\n    verify_property(property: str)->bool\n        Returns True if the property is met, and False otherwise.\n    best_text_match(string1: str, string2: str)->str\n        Returns the string that best matches the image.\n    crop(left: int, lower: int, right: int, upper: int)->ImagePatch\n        Returns a new ImagePatch object containing a crop of the image at the given coordinates.\n        """\n\n    def __init__(self, image, left: int=None, lower: int=None, right: int=None, upper: int=None):\n        """Initializes an ImagePatch object by cropping the image at the given coordinates and stores the coordinates as attributes.\n        If no coordinates are provided, the image is left unmodified, and the coordinates are set to the dimensions of the image.\n        Parameters\n        -------\n        image : array_like\n            An array-like of the original image.\n        left : int\n            An int describing the position of the left border of the crop\'s bounding box in the original image.\n        lower : int\n            An int describing the position of the bottom border of the crop\'s bounding box in the original image.\n        right : int\n            An int describing the position of the right border of the crop\'s bounding box in the original image.\n        upper : int\n            An int describing the position of the top border of the crop\'s bounding box in the original image.\n\n        """\n        if left is None and right is None and upper is None and lower is None:\n            self.cropped_image = image\n            self.left = 0\n            self.lower = 0\n            self.right = image.shape[2]  # width\n            self.upper = image.shape[1]  # height\n        else:\n            self.cropped_image = image[:, lower:upper, left:right]\n            self.left = left\n            self.upper = upper\n            self.right = right\n            self.lower = lower\n\n        self.width = self.cropped_image.shape[2]\n        self.height = self.cropped_image.shape[1]\n\n        self.horizontal_center = (self.left + self.right) / 2\n        self.vertical_center = (self.lower + self.upper) / 2\n\n    def find(self, object_name: str)->List["ImagePatch"]:\n        """Returns a new ImagePatch object containing the crop of the image centered around the object specified by object_name.\n        Parameters\n        -------\n        object_name : str\n            A string describing the name of the object to be found in the image.\n        """\n        return find_in_image(self.cropped_image, object_name)\n\n    def simple_query(self, question: str=None)->str:\n        """Returns the answer to a basic question asked about the image. If no question is provided, returns the answer to "What is this?".\n        Parameters\n        -------\n        question : str\n            A string describing the question to be asked.\n\n        Examples\n        -------\n\n        >>> # Which kind of animal is not eating?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     animal_patches = image_patch.find("animal")\n        >>>     for animal_patch in animal_patches:\n        >>>         if not animal_patch.verify_property("animal", "eating"):\n        >>>             return animal_patch.simple_query("What kind of animal is eating?") # crop would include eating so keep it in the query\n        >>>     # If no animal is not eating, query the image directly\n        >>>     return image_patch.simple_query("Which kind of animal is not eating?")\n\n        >>> # What is in front of the horse?\n        >>> # contains a relation (around, next to, on, near, on top of, in front of, behind, etc), so ask directly\n        >>> return image_patch.simple_query("What is in front of the horse?")\n        >>>\n        """\n        return simple_qa(self.cropped_image, question)\n\n    def exists(self, object_name: str)->bool:\n        """Returns True if the object specified by object_name is found in the image, and False otherwise.\n        Parameters\n        -------\n        object_name : str\n            A string describing the name of the object to be found in the image.\n\n        Examples\n        -------\n        >>> # Are there both cakes and gummy bears in the photo?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     is_cake = image_patch.exists("cake")\n        >>>     is_gummy_bear = image_patch.exists("gummy bear")\n        >>>     return bool_to_yesno(is_cake and is_gummy_bear)\n        """\n        return len(self.find(object_name)) > 0\n\n    def verify_property(self, object_name: str, property: str)->bool:\n        """Returns True if the object possesses the property, and False otherwise.\n        Differs from \'exists\' in that it presupposes the existence of the object specified by object_name, instead checking whether the object possesses the property.\n        Parameters\n        -------\n        object_name : str\n            A string describing the name of the object to be found in the image.\n        property : str\n            A string describing the property to be checked.\n\n        Examples\n        -------\n        >>> # Do the letters have blue color?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     letters_patches = image_patch.find("letters")\n        >>>     # Question assumes only one letter patch\n        >>>     if len(letters_patches) == 0:\n        >>>         # If no letters are found, query the image directly\n        >>>         return image_patch.simple_query("Do the letters have blue color?")\n        >>>     return bool_to_yesno(letters_patches[0].verify_property("letters", "blue"))\n        """\n        return verify_property(self.cropped_image, object_name, property)\n\n    def best_text_match(self, option_list: List[str]) -> str:\n        """Returns the string that best matches the image.\n        Parameters\n        -------\n        option_list : str\n            A list with the names of the different options\n        prefix : str\n            A string with the prefixes to append to the options\n\n        Examples\n        -------\n        >>> # Is the cap gold or white?\n        >>> def execute_command(image)->str:\n        >>>     image_patch = ImagePatch(image)\n        >>>     cap_patches = image_patch.find("cap")\n        >>>     # Question assumes one cap patch\n        >>>     if len(cap_patches) == 0:\n        >>>         # If no cap is found, query the image directly\n        >>>         return image_patch.simple_query("Is the cap gold or white?")\n        >>>     return cap_patches[0].best_text_match(["gold", "white"])\n        """\n        return best_text_match(self.cropped_image, option_list)\n\n    def crop(self, left: int, lower: int, right: int, upper: int)->"ImagePatch":\n        """Returns a new ImagePatch cropped from the current ImagePatch.\n        Parameters\n        -------\n        left : int\n            The leftmost pixel of the cropped image.\n        lower : int\n            The lowest pixel of the cropped image.\n        right : int\n            The rightmost pixel of the cropped image.\n        upper : int\n            The uppermost pixel of the cropped image.\n        -------\n        """\n        return ImagePatch(self.cropped_image, left, lower, right, upper)\n\n# Examples of using ImagePatch\n# Is there a backpack to the right of the man?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    man_patches = image_patch.find("man")\n    # Question assumes one man patch\n    if len(man_patches) == 0:\n        # If no man is found, query the image directly\n        return image_patch.simple_query("Is there a backpack to the right of the man?")\n    man_patch = man_patches[0]\n    backpack_patches = image_patch.find("backpack")\n    # Question assumes one backpack patch\n    if len(backpack_patches) == 0:\n        return "no"\n    for backpack_patch in backpack_patches:\n        if backpack_patch.horizontal_center > man_patch.horizontal_center:\n            return "yes"\n    return "no"\n\n# In which part is the bread, the bottom or the top?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    bread_patches = image_patch.find("bread")\n    # Question assumes only one bread patch\n    if len(bread_patches) == 0:\n        # If no bread is found, query the image directly\n        return image_patch.simple_query("In which part is the bread, the bottom or the top?")\n    if bread_patches[0].vertical_center < image_patch.vertical_center:\n        return "bottom"\n    else:\n        return "top"\n\n# What type of weather do you see in the photograph?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    return image_patch.simple_query("What type of weather do you see in the photograph?")\n\n# Who is the man staring at?\ndef execute_command(image)->str:\n    # asks for the predicate of a relational verb (staring at), so ask directly\n    image_patch = ImagePatch(image)\n    return image_patch.simple_query("Who is the man staring at?")\n\n# What toy is wearing a shirt?\ndef execute_command(image)->str:\n    # not a relational verb so go step by step\n    image_patch = ImagePatch(image)\n    toy_patches = image_patch.find("toy")\n    # Question assumes only one toy patch\n    if len(toy_patches) == 0:\n        # If no toy is found, query the image directly\n        return image_patch.simple_query("What toy is wearing a shirt?")\n    for toy_patch in toy_patches:\n        is_wearing_shirt = (toy_patch.simple_query("Is the toy wearing a shirt?") == "yes")\n        if is_wearing_shirt:\n            return toy_patch.simple_query("What toy is wearing a shirt?") # crop would include the shirt so keep it in the query\n    # If no toy is wearing a shirt, pick the first toy\n    return toy_patches[0].simple_query("What toy is wearing a shirt?")\n\n# What is behind the pole?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    # contains a relation (around, next to, on, near, on top of, in front of, behind, etc), so ask directly\n    return image_patch.simple_query("What is behind the pole?")\n\n# Are there bagels or lemons?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    is_bagel = image_patch.exists("bagel")\n    is_lemon = image_patch.exists("lemon")\n    return bool_to_yesno(is_bagel or is_lemon)\n\n# Is that blanket to the right of a pillow?\ndef execute_command(image)->str:\n    image_patch = ImagePatch(image)\n    blanket_patches = image_patch.find("blanket")\n    # Question assumes only one blanket patch\n    if len(blanket_patches) == 0:\n        # If no blanket is found, query the image directly\n        return image_patch.simple_query("Is that blanket to the right of a pillow?")\n    for blanket_patch in blanket_patches:\n        pillow_patches = image_patch.find("pillow")\n        for pillow_patch in pillow_patches:\n            if pillow_patch.horizontal_center > blanket_patch.horizontal_center:\n                return "yes"\n    return "no"\n\n# What is in the box?\ndef execute_command(image)->str:\n    # Ask the question directly\n    image_patch = ImagePatch(image)\n    return image_patch.simple_query("What is in the box?")']
Final accuracy: 0.0
